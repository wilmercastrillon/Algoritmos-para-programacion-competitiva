\documentclass[12pt, a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{titling}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{caption}

\usepackage{listings}%-para agregar codigo-
\usepackage[usenames,dvipsnames]{color}
\usepackage{color}%------------------------

%---------------------importar codigo desde archivos cpp----------------------------
\lstloadlanguages{C++}
\lstnewenvironment{code}
	{%\lstset{	numbers=none, frame=lines, basicstyle=\small\ttfamily, }%
	 \csname lst@SetFirstLabel\endcsname}
	{\csname lst@SaveFirstLabel\endcsname}
\lstset{% general command to set parameter(s)
	language=C++, basicstyle=\small\ttfamily, keywordstyle=\slshape,
	emph=[1]{tipo,usa}, emphstyle={[1]\sffamily\bfseries},
	morekeywords={tint,forn,forsn},
	basewidth={0.47em,0.40em},
	columns=fixed, fontadjust, resetmargins, xrightmargin=5pt, xleftmargin=15pt,
	flexiblecolumns=false, tabsize=2, breaklines,	breakatwhitespace=false, extendedchars=true,
	numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=9pt,
	frame=l, framesep=3pt,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{magenta}\ttfamily,
    commentstyle=\color{RedOrange}\ttfamily,
    morecomment=[l][\color{OliveGreen}]{\#}
}

\lstdefinestyle{C++}{
	language=C++, basicstyle=\small\ttfamily, keywordstyle=\slshape,
	emph=[1]{tipo,usa,tipo2}, emphstyle={[1]\sffamily\bfseries},
	morekeywords={tint,forn,forsn},
	basewidth={0.47em,0.40em},
	columns=fixed, fontadjust, resetmargins, xrightmargin=5pt, xleftmargin=15pt,
	flexiblecolumns=false, tabsize=2, breaklines,	breakatwhitespace=false, extendedchars=true,
	numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=9pt,
	frame=l, framesep=3pt,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{magenta}\ttfamily,
    commentstyle=\color{RedOrange}\ttfamily,
    morecomment=[l][\color{OliveGreen}]{\#}
}

\def\nbtitle#1{\begin{Large}\begin{center}\textbf{#1}\end{center}\end{Large}}
\def\nbsection#1{\section{#1}}
\def\nbsubsection#1{\subsection{#1}}
\def\nbcoment#1{\begin{small}\textbf{#1}\end{small}}
\newcommand{\comb}[2]{\left( \begin{array}{c} #1 \\ #2 \end{array}\right)}
\def\complexity#1{\texorpdfstring{$\mathcal{O}(#1)$}{O(#1)}}
 \newcommand\cppfile[2][]{
\lstinputlisting[style=C++,linerange={#1}]{#2}
}
%%------------------------------------------------------------------------------

\newcommand{\subtitulo}[1]{\begin{center}\textbf{#1}\end{center}}

\title{\textbf{Grafos}}
\author{Wilmer Emiro Castrillón Calderón}

\graphicspath{{../}}
\newcommand*\lstinputpath[1]{\lstset{inputpath=#1}}
\lstinputpath{../}

\begin{document}
	\maketitle
	
	%<*Capitulo>
	
	\section{Teoría de grafos}
	Los grafos son una estructura de datos donde se pueden relacionar distintos objetos entre si, los grafos se pueden
	definir como un conjunto de nodos(objetos) unidos por aristas(relaciones), estos son estudiados por la
	matemática y las ciencias de la computación, esta rama se conoce como teoría de grafos, ademas tienen muchas 
	aplicaciones, por ejemplo permiten modelar redes informáticas, sistemas de carreteras, redes sociales, etc.
	
	\subtitulo{Terminología general}
	Los grafos se pueden clasificar de distintas formas, las mas utilizadas son:
	\begin{enumerate}[1.]
		\item \textbf{Grafos ponderados y no ponderados} Si las aristas de un grafo tienen un peso, es decir si para
			atravesar una arista esta tiene un costo asociado, entonces el grafo se clasifica como ponderado, pero si 
			ninguna arista tiene algún costo entonces el grafo se clasifica como no ponderado.
		\item \textbf{Grafos dirigidos y no dirigidos:} Si un grafo posee por lo menos una arista dirigida entonces
		 	se clasifica como un grafo dirigido, una arista $(A,B)$ es dirigida si esta permite el paso de $A$ hacia 
		 	$B$, pero no permite ir de $B$ hacia $A$. Si todas las aristas son bidireccionales(no dirigidas) entonces 
		 	el grafo se clasifica como no dirigido.
		\item \textbf{Grafos cíclicos y acíclicos} Se considera un grafo como acíclico cuando este no tiene ciclos, es
			decir para cada pareja de nodos $(A,B)$ si existe un camino para ir de $A$ hacia $B$ entonces no existe 
			otro camino para ir de $B$ hacia $A$. Si un grafo no es acíclico entonces este es cíclico.
		\item \textbf{Grafos conexos y no conexos} Si para cada pareja de nodos $(A,B)$ existe un camino para ir de 
			$A$ hacia $B$ y también existe camino para ir de $B$ hacia $A$ entonces el grafo es conexo, en caso 
			contrario es un grafo no conexo.
	\end{enumerate}
	
	\subtitulo{Representación.}
	
	Los grafos se pueden representar de múltiples maneras cada una permite realizar distintos algoritmos, cada forma 
	de representar los grafos se puede ajustar según su tipo, un aspecto importante a considerar es que cada una arista
	bidireccional $(A,B)$ se puede interpretar como dos aristas dirigidas $(A,B)$ y $(B,A)$. Existen principalmente de
	tres formas distintas de representarlos:
	
	\begin{enumerate}[1.]
		\item \textbf{Matriz de adyacencia:} Es una matriz $M$ en la cual cada fila representa un nodo de inicio y cada
			columna un nodo destino(a cada nodo se le asignara un numero representando su posición en fila y columna), 
			si existe una arista $(A,B)$ entonces se marca la casilla $M_{A,B}$, en el caso de grafos ponderados se
			debe llenar $M_{A,B}$ con el costo de la arista $(A,B)$, para los todos los pares de nodos que no tengan
			aristas entre ellos el costo es infinito. Si el grafo es no ponderado entonces en la matriz simplemente se
			marca si existe o no la arista $(A,B)$. Por definición cada nodo tiene conexión con sí mismo con costo cero.
		\item \textbf{Lista de adyacencia:} Consiste en guardar para cada nodo una lista con las conexiones que posee,
		 	es decir, para cada arista $(A,B)$ se pondrá en la lista de conexiones de $A$ el nodo $B$. Si el grafo es
		 	ponderado entonces se deberá guardar el nodo destino junto con su costo. Esta es la manera mas utilizada 
		 	para representar grafos, pues el espacio de memoria que ocupa es menor que el utilizado por una matriz de
		 	adyacencia y ademas facilita recorrer el grafo de manera sencilla.
		\item \textbf{Lista de aristas:} Consiste en una lista en la cual se guardara todas las aristas de un grafo, 
			para cada una se guarda el nodo de inicio, nodo de destino y el costo en caso de tener. Esta es la menos
			 utilizada de las tres, aunque facilita ordenar las aristas según su costo.
	\end{enumerate}
	
	A continuación se muestra un pequeño ejemplo para cada una de las tres formas:
	
	\begin{figure}[!htb]
		\minipage{0.5\textwidth}
			\centering
			\includegraphics[scale=1]{Grafos/imagenes/grafo_ejemplo}
			\caption{}%\label{fig:awesome_image1}
		\endminipage
		\minipage{0.55\textwidth}
			\centering
			\cppfile[7-16]{Grafos/codigos/Grafos.cpp}
			Matriz de adyacencia
		\endminipage
	\end{figure}	
	
	\begin{figure}[!htb]
		\minipage{0.5\textwidth}
			\centering
			\cppfile[19-27]{Grafos/codigos/Grafos.cpp}
			Lista de adyacencia
		\endminipage
		\minipage{0.55\textwidth}
			\centering
			\cppfile[30-39]{Grafos/codigos/Grafos.cpp}
			Lista de aristas
		\endminipage
	\end{figure}	
	
	\section{DFS y BFS}
	
	Los grafos son estructuras no lineales, estos no tienen un nodo inicio o un orden especifico para recorrerlos,
	existen principalmente dos algoritmos que permiten recorrer un grafo DFS y BFS, estos no son algoritmos muy
	estrictos, es decir, se pueden modificar de múltiples maneras para realizar diferentes tareas, sin embargo la 
	idea básica sigue siendo la misma, para la implementación de ambos se utiliza una lista de adyacencia.
	
	\subtitulo{DFS.}
	
	El DFS (deep first search) o búsqueda en profundidad, es un algoritmo que permite recorrer un grafo de forma
	recursiva, de manera general consiste en tomar un nodo, marcarlo como visitado y para cada arista hacer un 
	llamado recursivo al nodo destino, solo si ese nodo no esta visitado, y repetir el proceso hasta que no queden mas
	nodos por visitar. De esta forma se van marcando los nodos mientras se visitan y en caso de llegar a un nodo sin
	aristas o un nodo cuyos vecinos se encuentran visitados entonces se devuelve al nodo anterior.\\
	
	En la siguientes figuras se observa el orden en el cual los nodos son visitados empezando por el nodo 1, 
	entonces comienza con el 1, después avanza al 5 y luego al 4, como no hay mas destinos se devuelve al 5,
	pero su único vecino ya esta visitado, se devuelve al 1, desde ahi pasa al 3, este no tiene vecinos y se
	devuelve otra vez al 1, y finalmente al 2, como su vecino ya esta visitado regresa al 1, y como este no tiene
	mas vecinos finaliza el algoritmo.
	
	\begin{figure}[!htb]
		\minipage{0.5\textwidth}
			\centering
			\includegraphics[scale=1]{Grafos/imagenes/DFS1}
			\caption{}%\label{fig:awesome_image1}
		\endminipage
		\minipage{0.5\textwidth}
			\centering
			\includegraphics[scale=1]{Grafos/imagenes/DFS2}
			\caption{}%\label{fig:awesome_image1}
		\endminipage
	\end{figure}	
	
	La implementacion del DFS es corta y consiste básicamente en un algoritmo de backtraking, tiene una complejidad
	algorítmica O($V+E$) con $V$ como el numero de nodos y $E$ como el numero de aristas.
	\cppfile[6-16]{Grafos/codigos/DFS.cpp}
	
	\subtitulo{BFS.}
	
	El BFS(Breadth First Search) o búsqueda en anchura es un algoritmo que permite recorrer un grafo de forma
	iterativa, la idea consiste en tomar un nodo inicial y recorrer todos los nodos que están a un "salto" de 
	distancia(es decir, sus vecinos), después los nodos que están a dos "saltos" de distancia y así sucesivamente hasta
	recorrer todos los nodos.\\
	
	La implementación consiste de utilizar una cola(queue) inicialmente con un nodo, este nodo se debe marcar como
	visitado, después se empieza a iterar los elementos en la cola, en cada iteración se desencola el siguiente nodo,
	después se agrega todos sus nodos vecinos no visitados a la cola y se marcan como visitados, el algoritmo termina
	cuando la cola queda vacía. En la siguiente figura se observa el orden en el cual se visitan los nodos en el grafo
	de ejemplo anterior.
	
	\begin{figure}[!htb]
		\minipage{0.5\textwidth}
			\centering
			\includegraphics[scale=1]{Grafos/imagenes/BFS1}
			\caption{}%\label{fig:awesome_image1}
		\endminipage
		\minipage{0.5\textwidth}
			\centering
			\includegraphics[scale=1]{Grafos/imagenes/BFS2}
			\caption{}%\label{fig:awesome_image1}
		\endminipage
	\end{figure}	
	
	La implementacion del BFS es sencilla, tiene una complejidad algorítmica O($V+E$) al igual que el DFS, ademas al 
	ser iterativo evita los problemas de stack overflow que puede presentar el DFS al trabajar con grafos muy extensos.	
	\cppfile[8-25]{Grafos/codigos/BFS.cpp}
	
	\subtitulo{Observaciones.}
	
	Ambos algoritmos son igual de buenos para recorrer grafos de forma general, dependiendo del problema a resolver
	uno de los dos algoritmos puede resultar mejor que el otro, esto se debe a las distintas formas de recorrer
	los grafos, el DFS al ser un algoritmo recursivo permite recorrer los nodos de una forma ordenada, siguiendo un
	camino en el cual cada nodo es vecino del anterior, en cambio el BFS permite recorrer los grafos por niveles, 
	comenzando con los nodos mas cercanos al nodo inicial, de esta forma se puede encontrar mas fácil distancias entre
	los distintos nodos. Al utilizar DFS se debe tener cuidado con la pila de memoria(call stack) la cual se puede
	llenar rápidamente con grafo extensos, produciendo errores de ejecución.
	
	
	\section{Bibliografia}
	https://es.wikipedia.org/wiki/Grafo\\
	http://trainingcamp.org.ar/anteriores/2017/clases.shtml.\\ 
	libro: competitive programming 3.\\ 



	%</Capitulo>
	
	
	
\end{document}



